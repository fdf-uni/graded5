[{"name":"app.R","content":"# Exercise Sheet 5\n# Authors: github.com/fdf-uni\n\n# For this GitHub version I removed some comments here which aren't too\n# important for the below code and rather just answers to exercises\n# from the exercise sheet. You can ignore numbers followed by a closing\n# bracket in comments below as they also are only there to indicate which\n# exercise the corresponding code belongs to.\n\nlibrary(shiny)\nlibrary(ggplot2)\n# 3) More themes\nlibrary(bslib)\n# 3) Also update ggplot themes\nlibrary(thematic)\n# 3) Better table output capabilities\nlibrary(DT)\n\n# Generate correlated data given correlation and number of observations\ngenerate_correlated_data <- function(correlation, n) {\n  alpha <- correlation\n  beta <- sqrt(1 - correlation^2)\n\n  x1 <- runif(n)\n  x2 <- runif(n)\n\n  x_correlated <- alpha * x1 + beta * x2\n\n  # 3) Also order data frame to make it look nicer in the table output\n  return(data.frame(x1, x2 = x_correlated)[order(x1), ])\n}\n\n# 3) Custom theme\ncustom_theme <- bs_theme(\n  version = 5,\n  preset = \"sketchy\"\n)\n\n# 3) Make plot(s) respect custom theme\nthematic_shiny()\n\n# 1a) Adjust title to include my name\ntitle_str <- \"Correlation Game by fdf\"\n\n# Define UI\nui <- fluidPage(\n  title = title_str,\n  theme = custom_theme,\n  # 3) Add theme selector and switch for dark mode\n  fluidRow(\n    # 1a) Adjust title to include name\n    column(8, titlePanel(title_str)),\n    column(\n      3,\n      shinyWidgets::pickerInput(\n        \"themeSelection\",\n        \"Theme: \",\n        choices = c(builtin_themes(), bootswatch_themes()),\n        selected = \"sketchy\",\n        width = \"fit\"\n      )\n    ),\n    column(\n      1,\n      align = \"right\",\n      input_dark_mode(id = \"dark_mode\", mode = \"light\")\n    ),\n  ),\n  # 1b) Add input field and display for the player's name\n  fluidRow(\n    column(4, textInput(\"nameInput\", \"What's your name?\")),\n    column(\n      6, textOutput(\"nameOutput\"),\n      tags$head(tags$style(\"#nameOutput{font-size: 20px; font-style: bold;}\"))\n    ),\n    # 3) Button to generate new data\n    column(\n      2, align = \"right\",\n      actionButton(\"newDataButton\", \"New Data\", icon = icon(\"dice-five\"))\n    )\n  ),\n  # Create Panel with different tabsets\n  tabsetPanel(\n    # Tabset for scatter plot\n    tabPanel(\n      \"Scatter Plot\",\n      plotOutput(\"scatterPlot\"),\n      # 1c) Input for player's correlation guess\n      sliderInput(\n        \"guess\", \"Try to guess the correlation!\",\n        min = -1, max = 1, value = 0, step = 0.01,\n        width = \"100%\"\n      )\n    ),\n\n    # Tabset for solution\n    tabPanel(\n      \"Solution\",\n      sidebarLayout(\n        mainPanel(\n          h5(\"Correlation\"),\n          verbatimTextOutput(\"correlationOutput\"),\n          h6(\"You were this far off: \"),\n          verbatimTextOutput(\"guessOutputValue\"),\n          fluidRow(\n            column(\n              6,\n              align = \"left\",\n              textOutput(\"guessOutputCongrats\"),\n              tags$head(tags$style(\n                \"#guessOutputCongrats{font-size: 20px; font-style: bold;}\"\n              ))\n            ),\n            column(6, align = \"right\", uiOutput(\"twitterShareButton\"))\n          )\n        ),\n        sidebarPanel(\n          h5(\"Interpretation\"),\n          htmlOutput(\"interpretation\")\n        ),\n      ),\n    ),\n\n    # 2) Tabset for Sandbox\n    tabPanel(\n      \"Sandbox\",\n      sliderInput(\n        \"correlationRange\", \"Range of correlation\",\n        min = -1, max = 1, value = 0, step = 0.01,\n        width = \"100%\"\n      ),\n      numericInput(\n        \"numberOfObservations\", \"Number of observations\", 100,\n      )\n    ),\n\n    # 3) Tabset for data\n    tabPanel(\n      \"Data\",\n      sidebarLayout(\n        mainPanel(\n          h5(\"Currently plotted data\"),\n          p(\"Double click entries to edit them.\"),\n          dataTableOutput(\"dataOutput\"),\n        ),\n        sidebarPanel(\n          h5(\"Enter your own data\"),\n          textAreaInput(\n            \"dataInput\",\n            \"Please provide your data as a comma-separated table with each row\n            on a new line and no column names.\n            Only two columns are supported.\",\n            rows = 10\n          ),\n          fluidRow(\n            column(\n              6,\n              align = \"left\",\n              actionButton(\"dataPasteButton\", \"Insert current data\")\n            ),\n            column(\n              6,\n              align = \"right\",\n              actionButton(\"dataInputButton\", \"Submit\")\n            ),\n          ),\n          htmlOutput(\"dataInputResult\"),\n          htmlOutput(\"dataInputError\")\n        ),\n      )\n    ),\n    # 3) Tabset for app information\n    tabPanel(\n      \"About\",\n      p(\"This app was created as a solution to the fifth graded exercise sheet\n        in the Advanced Statistical Programming course at LMU Munich.\"),\n      p(\"All credit for the general idea as well as some parts of the code goes\n        to the corresponding lecture team.\"),\n      p(\n        \"If you are interested in how this app works, you can check out it's\n        source code on\",\n        a(\n \t  \"GitHub\",\n\t  href = \"https://github.com/fdf-uni/graded5\",\n\t  target = \"_blank\",\n\t  rel = \"noopener noreferrer\"\n\t),\n        \".\"\n      ),\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  # 2) Store df as reactive value such that outputs update when it changes\n  values <- reactiveValues(\n    # Initialize it as a data frame with 100 rows and correlation which is\n    # chosen randomly according to uniform distribution on (-1, 1)\n    df = generate_correlated_data(correlation = runif(1, -1, 1), n = 100)\n  )\n\n  # 1b) Store and display player's name\n  name <- reactive({\n    input$nameInput\n  })\n  output$nameOutput <- renderText({\n    paste0(\"Currently playing: \", name())\n  })\n\n  # Create scatter plot\n  output$scatterPlot <- renderPlot({\n    ggplot(values$df, aes(x = x1, y = x2)) +\n      geom_point() +\n      labs(x = \"x1\", y = \"x2\")\n  })\n\n  # Reactive helper variables\n  correlation <- reactive(cor(values$df$x1, values$df$x2))\n  difference <- reactive(abs(correlation() - input$guess))\n\n  # Print the current correlation in the \"Solution\" tabset.\n  output$correlationOutput <- renderPrint(correlation())\n\n  # 1d) Add output for distance of guess to actual correlation\n  output$guessOutputValue <- renderPrint(difference())\n  # Conditionally add congratulation text\n  output$guessOutputCongrats <- renderText({\n    if (difference() < 0.1) \"Great Guess!\"\n  })\n\n  # 1e) Provide interpretation of correlation coefficient\n  output$interpretation <- renderText({\n    paste0(\n      \"<b>Direction:<\/b> \",\n      if (correlation() >= 0) \"positive\" else \"negative\",\n      \"<br/><b>Magnitude:<\/b> \",\n      if (abs(correlation()) <= 0.3) {\n        \"weak\"\n      } else if (abs(correlation()) <= 0.7) {\n        \"moderate\"\n      } else {\n        \"strong\"\n      }\n    )\n  })\n\n  # 3) Function to output currently plotted data (I need to use it multiple\n  # times since the column headers get a bit messed up when using replaceData\n  # with completely new dataframes).\n  update_data_table <- function() {\n    output$dataOutput <- renderDataTable({\n      datatable(\n        # Isolate df here so that the table doesn't have to be regenerated\n        # with every edit in the table output. Also add id column.\n        isolate(cbind(id = seq_len(nrow(values$df)), values$df)),\n        editable = list(\n          target = \"cell\", disable = list(columns = 0)\n        ),\n        rownames = FALSE,\n        options = list(\n          scrollY = \"400px\",\n          order = list(list(0, \"asc\")),\n          pageLength = 100,\n          lengthMenu = list(\n            c(10, 25, 50, 100, -1),\n            c(\"10\", \"25\", \"50\", \"100\", \"All\")\n          )\n        )\n      )\n    })\n  }\n  update_data_table()\n\n  # Update data when user edits cells\n  observeEvent(input$dataOutput_cell_edit, {\n    info <- input$dataOutput_cell_edit\n    values$df[info$row, info$col] <- info$value\n    replaceData(\n      dataTableProxy(\"dataOutput\"),\n      isolate(cbind(id = seq_len(nrow(values$df)), values$df)),\n      rownames = FALSE\n    )\n  })\n  # React to submission button with some (basic) error handling\n  observeEvent(\n    input$dataInputButton,\n    {\n      tryCatch(\n        {\n          table <- read.table(\n            text = input$dataInput, sep = \",\",\n            # Ensure correct naming and type of columns\n            col.names = c(\"x1\", \"x2\"), colClasses = rep(\"numeric\", 2)\n          )\n          values$df <- as.data.frame(table)[order(table$x1), ]\n          update_data_table()\n          # Show success message\n          output$dataInputResult <- renderText(\"Successfully imported data!\")\n          output$dataInputError <- renderText(\"\")\n        },\n        error = function(e) {\n          output$dataInputResult <- renderText({\n            paste(\n              \"Please ensure that your data are formatted correctly,\n            i.e. as described above.<br/>\",\n              \"R error:<br/>\"\n            )\n          })\n          output$dataInputError <- renderText({\n            paste(\"<font color=\\\"#FF0000\\\"><b>\", e, \"<\/b><\/font>\")\n          })\n        }\n      )\n    }\n  )\n  # Paste current data to data input field when pressing corresponding button\n  observeEvent(input$dataPasteButton, {\n    updateTextAreaInput(\n      session, \"dataInput\",\n      value = paste(\n        do.call(paste, c(values$df[order(values$df$x1), ], sep = \",\")),\n        collapse = \"\\n\"\n      )\n    )\n  })\n\n  # 2) Update scatter plot and solution fields on changes to variables in\n  # sandbox tabset. Note that since df was turned into a reactive variable this\n  # can be done in a very short manner as only df needs to be updated.\n  observeEvent(input$correlationRange | input$numberOfObservations, {\n    values$df <- generate_correlated_data(\n      correlation = input$correlationRange,\n      n = input$numberOfObservations\n    )\n    # 3) Also update the data view\n    update_data_table()\n  })\n\n  # 3) Update theme on selection\n  observeEvent(input$themeSelection, {\n    session$setCurrentTheme(\n      bs_theme_update(custom_theme, preset = input$themeSelection)\n    )\n  })\n\n  # 3) Share results on twitter when pressing the corresponding button\n  # Do all this dynamically such that a new guess creates a new link\n  output$twitterShareButton <- renderUI({\n    shiny::a(\n      h4(icon(\"x-twitter\"),\n        \"Share your result\",\n        class = \"btn btn-default action-button\",\n        style = \"fontweight:600\"\n      ),\n      target = \"_blank\",\n      rel = \"noopener noreferrer\",\n      href = paste0(\n        \"https://x.com/intent/tweet?\",\n        \"url=https%3A%2F%2Ffdf-uni.github.io%2Fgraded5%2F\",\n        \"&text=I+just+was+only+off+by+approximately+\",\n        round(difference(), digits = 3),\n        \"+when+guessing+a+correlation+of+approximately+\",\n        round(correlation(), digits = 3),\n        \"+in+a+scatter+plot%21\",\n        \"+How+good+are+you%3F%0A\"\n      )\n    )\n  })\n\n  # Generate new random data whenever the corresponding button is pressed\n  observeEvent(input$newDataButton, {\n    values$df <- generate_correlated_data(correlation = runif(1, -1, 1), n = 100)\n    update_data_table()\n  })\n}\n\n# Run the application\nshinyApp(ui = ui, server = server)\n","type":"text"}]
